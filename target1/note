1.关于栈的指针
  返回栈指针在当前栈顶的上面。
  因为栈是从上向下拓展，并且栈顶在最上面。
  比如：当前函数帧是 [1000'000, 1000'010]。则返回栈指针为 [1000'011, 1000'018]
  在当前函数帧最高位的上面，小端读取，所以反写。

2.关于caller save调用者保存, callee save被调用者保存 (x86-64 Linux Register Usage)
  书上说：
    所有其它的寄存器，除了栈指针%rsp，都分类为调用者保存(caller save)寄存器。
    %rbx,%r12,%r13,%r14是被调用者保存(callee save)
    %rsp是一个特殊的被调用者保存(callee save), 被保存到原值用于退出函数
    %rbp是被调用者保存，被调用者必须保存并存储，也许会被用作函数帧指针，可以混用和比较。

3.x86-64, 64位，所以8字节，地址也是64位，指令也是64位。

4.pushq, popq，会将数据压入栈
  call是先把pushq rsp，再jump。
  ret 是先popq rsp，再jump。
  所以，只要利用这一点就可以进行jump。

5.rtarget没有金丝雀

6.rtarget 栈随机化，但是可执行代码部分没有随机化。

7.rtarget 没有栈越界检测，不然没法写