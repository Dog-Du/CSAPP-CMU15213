1.关于函数传递
  bufbomb lab是x86-32，而不是x86-64，与attack lab不同
  x86-32参数传递的方法是倒序压入栈
  x86-64参数传递的方式是使用%rdi等寄存器，不够用了再用栈
2.关于返回栈指针在内存地址的存放位置。
  x86-64是直接放在栈帧之上。
  x86-32存在一个保存原来%ebp的操作
    因此栈帧再加4字节（因为x86-32是32为地址，所以加4字节）
    所以返回栈指针在内存地址的存放位置为栈帧+4字节之上
3.关于push
  因为是x86-32系统，push不可能一次性压入8个字节
  因此可以考虑把立即数分成高低各4个字节，两次压入栈中
  这样就可以在使用的时候使用 mov 0x8(%ebp), %eax 的形式直接送给 eax
4.关于在不修复时为什么段错误
  在进行level3的时候，要求修复栈，而且要求在完成getbuf返回时，local值不变。
  必须要知道的是，只修改栈顶的返回栈指针并不会破坏local值。
  这点可以通过尝试得知，可以先注入代码，不做特别的事情，只是返回getbuf函数下方。
  记住调用getbuf前的%esp, %ebp，然后gdb的x指令查看local值所在内存
  可以发现，local值没有发生变化
  那么为什么会在之后出现段错误，其实是因为esp和ebp被破坏导致的
  在gdb下使用info frame 1，可以看到返回了错误的信息，这是导致段错误的原因。
5.关于%esp和%ebp之间的关系
  x86-32中，在一个栈空间中，完成栈空间的拓展之后，leave之前，存在如下关系：
    %ebp = %esp + 拓展的栈空间
6.关于项目的一个说明
  buflab32.pdf的level4说：
    从一次运行到另一次运行，尤其是不同用户之间，给定过程使用的精确栈位置会有所不同。
    这种差异的一个原因是，当程序开始执行时，所有环境变量的值都放置在栈的底部附近。
    环境变量作为字符串存储，根据其值需要不同的存储量。因此，为给定用户分配的栈空间取决于其环境变量的设置。
  其实就是传入的参数 -u <用户名> 中用户名字符串长度不同导致的
  C语言的main函数声明为 int main(int argc, char *args[])
  这和 char *args[] 有一定关系

