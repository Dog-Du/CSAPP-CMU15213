# 1 引言 

  网络代理是作为Web浏览器与终端服务器之间中介的程序。浏览器不会直接联系终端服务器获取网页，而是通过代理服务器转发请求。当终端服务器向代理返回响应时，代理再将响应转发给浏览器。 代理服务器具有多种用途。有时被用于防火墙中，使得防火墙后的浏览器只能通过代理与外部服务器通信。代理也可作为匿名器使用：通过剥离请求中的所有身份信息，使Web服务器无法识别浏览器的身份。代理甚至可以通过缓存服务器内容实现Web对象存储，后续请求可直接从本地缓存读取而不必再次访问远程服务器。 在本实验中，您将实现一个支持缓存功能的简易HTTP代理。实验第一部分需要搭建代理基础架构，实现连接接收、请求解析、请求转发、响应读取和响应回传功能。这部分内容将帮助您掌握HTTP基础协议，并学习使用套接字进行网络通信编程。 实验第二部分将代理升级为支持多并发连接处理，通过这一过程您将接触到系统开发中至关重要的并发处理概念。在第三部分即最终环节，您将为代理添加基于最近访问内容的主存缓存机制，实现简单的缓存功能。



# 2 项目说明   

本项目为个人独立完成任务。 

# 3 实验资料获取说明   

（此处需根据具体教学环境补充说明教师如何向学生分发 `proxylab-handout.tar` 文件。）  

 请将实验资料文件复制到 Linux 工作环境下的受保护目录中，

并执行以下命令：   

```bash   linux> tar xvf proxylab-handout.tar   ```   

此操作将生成名为 `proxylab-handout` 的实验资料目录，目录中的 `README` 文件包含各文件的功能描述。 

#  4 第一部分：实现顺序式 Web 代理   

第一步是实现一个基础的顺序式代理，支持处理 HTTP/1.0 的 GET 请求（其他如 POST 类型的请求可选实现）。   代理启动后，需监听命令行指定端口上的传入连接。建立连接后，代理应完整读取客户端请求并解析。需验证请求是否符合 HTTP 协议规范：若合法，则代理需连接到目标 Web 服务器，请求客户端指定的资源对象，最后将服务器的响应回传给客户端。   

## 4.1 HTTP/1.0 GET 请求解析   

当用户在浏览器地址栏输入类似 `http://www.cmu.edu/hub/index.html` 的 URL 时，浏览器会向代理发送 HTTP 请求，首行示例如下：   ```   ``` 

 ```GET http://www.cmu.edu/hub/index.html HTTP/1.1   ```  

 代理需将请求解析为以下字段：   

- **主机名**：`www.cmu.edu`   

- - **路径及后续内容**：`/hub/index.html`   

  - 解析完成后，代理应连接到 `www.cmu.edu` 并向其发送如下格式的 HTTP 请求：

       ```   GET /hub/index.html HTTP/1.0   ```   

    **注意事项**：   1. HTTP 请求的每一行均以回车符 `\r` 加换行符 `\n` 结尾。   2. 每个 HTTP 请求必须通过空行 `"\r\n"` 终止。

通过上述示例可见，浏览器请求行以 `HTTP/1.1` 结尾，而代理生成的请求行则以 `HTTP/1.0` 结尾。现代浏览器通常生成 `HTTP/1.1` 请求，但代理需将其转换为 `HTTP/1.0` 格式进行转发。 需要特别注意的是，HTTP 请求（即使仅关注 `HTTP/1.0` 的 GET 请求子集）可能具有极高的复杂性。教材中描述了 HTTP 交互的某些细节，但完整规范需参考 **RFC 1945**（HTTP/1.0 标准文档）。理想情况下，代理的 HTTP 请求解析器应严格遵循 RFC 1945 相关章节的规范，但存在一个例外：尽管标准允许请求字段跨多行，但**代理无需支持多行请求字段的解析**。此外，代理必须确保**不会因请求格式错误而异常终止**。



## 4.2 请求头部处理   

本实验中需重点处理的请求头部包括 **Host**、**User-Agent**、**Connection** 和 **Proxy-Connection**：  

1. **必须发送 Host 头部**    

   尽管 HTTP/1.0 规范未明确要求，但包含 Host 头部是必要的，这能确保从某些使用虚拟主机的 Web 服务器获取有效响应。    

   Host 头部指定目标服务器的主机名。例如，访问 `http://www.cmu.edu/hub/index.html` 时，代理应发送：       ```       ``` 

   ```Host: www.cmu.edu       ```   

   若浏览器请求中已包含 Host 头部，代理应直接沿用该值。  

2. **建议发送固定 User-Agent 头部**     

   可统一发送以下 User-Agent 头部（示例因排版分两行显示，实际需作为单行发送）：       ```  ``` 

    ```     User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:10.0.3) Gecko/20120305 Firefox/10.0.3       ```     

    User-Agent 用于标识客户端环境（如操作系统、浏览器类型）。发送此特定值可在简单测试（如 Telnet）时获取更丰富多样的响应内容。     - 注：`proxy.c` 文件中已将此 User-Agent 字符串定义为常量供直接调用。   

3. **必须发送 Connection 头部**     

    始终添加：       ```       ``` 

    ```Connection: close       ```  

4. **必须发送 Proxy-Connection 头部**     

   始终添加：       ```       ``` 

    ```Proxy-Connection: close       ```     

   **作用**：这两个头部通知服务器代理将在完成单次请求/响应后关闭连接。建议代理为每个请求新建连接以提高可靠性。   

   **其他头部处理**：   

    若浏览器请求中包含其他头部字段（如 `Accept`、`Cookie` 等），代理需原样转发至目标服务器。   

   

   ## 4.3 端口号管理   

   本实验涉及两类端口号：

   **HTTP 请求端口** 和 **代理监听端口**。   

   1. **HTTP 请求端口**     

      URL 中可能包含显式端口号，例如：   

      ​    ```       http://www.cmu.edu:8080/hub/index.html       ```     

      此时代理应连接至 `www.cmu.edu` 的 **8080 端口**（默认 HTTP 端口为 80）。     

      代理需兼容带端口号和不带端口号的 URL。   

   2. **代理监听端口**     

      代理启动时需通过命令行参数指定监听端口，例如：

      ​       ```bash       linux> ./proxy 15213       ```     

   3. **端口选择规则**：       

      必须使用 **非特权端口**（范围：1025 ~ 65535）。       

      为避免端口冲突，需使用脚本 `port-for-user.pl` 生成唯一端口号。

      例如：         ```bash         linux> ./port-for-user.pl droh         droh: 45806         ```       

      该脚本生成的端口号为偶数，因此可安全使用 `p` 和 `p+1`（如同时运行 Tiny 服务器时）。     

   4. **禁止随机选择端口**：手动指定端口可能导致与其他用户进程冲突。   

   5. **关键提示**：   - 实验框架中已提供 `port-for-user.pl` 脚本，确保按用户 ID 生成专属端口号，保障多用户环境下的协作安全。

      

## 5 第二部分：处理多并发请求   

在完成顺序式代理后，需将其升级为支持**多请求并发处理**。   

**实现方案**：   

* **多线程模型**：最简方法是为每个新连接创建独立线程处理请求。也可参考教材 12.5.5 节的预线程化（prethreaded）服务器设计。   

* **线程分离模式**：确保线程以**分离模式（detached mode）**运行，避免内存泄漏。   -

*  **线程安全函数**：实验框架中基于 `getaddrinfo` 实现的 `open_clientfd` 和 `open_listenfd` 函数为线程安全，可放心调用。   

  ## 6 第三部分：实现 Web 对象缓存   

  本部分需为代理添加内存缓存机制，存储最近访问的 Web 对象。代理采用简化的缓存策略（忽略 HTTP 标准中的复杂缓存指令）：   

  - **缓存流程**：    

    1. 代理从服务器获取对象时，将其缓存至内存，同时转发给客户端。    

    2. 若其他客户端请求同一对象，代理直接返回缓存副本，无需重新连接服务器。   

  * **缓存限制**：    

    **总缓存容量**：`MAX_CACHE_SIZE = 1 MiB`（仅计算实际存储对象的字节，元数据不计）。    

    **单个对象最大尺寸**：`MAX_OBJECT_SIZE = 100 KiB`（超过此值的对象不缓存）。   

    - 注：上述常量已在 `proxy.c` 中宏定义。   

  * **实现方法**：    

    1. **缓冲区分配**：为每个活动连接分配缓冲区，接收服务器数据时逐步累积。    

    2. **尺寸检查**：       

       若缓冲区大小超过 `MAX_OBJECT_SIZE`，丢弃该缓冲区。       

       若完整读取响应且未超限，则将对象存入缓存。    

    3. **内存管理**：       

       - 总内存消耗上限为 `MAX_CACHE_SIZE + T * MAX_OBJECT_SIZE`（`T` 为最大并发连接数）。   
       - **缓存替换策略**（需自行设计）：   
       - 当缓存空间不足时，需淘汰旧对象（如 LRU 策略）。建议使用链表结构管理缓存条目。   
       - **线程安全要求**：  
         - 缓存操作（如读写、替换）需保证**线程安全**，避免多线程竞争导致数据不一致。   

       * **注意事项**：   - 缓存仅存储原始对象数据，无需记录附加信息（如请求头、时间戳等）。    

         确保并发环境下缓存状态的一致性，可使用互斥锁（mutex）或读写锁（read-write lock）保护共享资源。

## 6.3 缓存淘汰策略   

代理缓存需采用近似 **最近最少使用（LRU）** 的淘汰策略。

该策略无需严格符合 LRU 标准，但需在逻辑上接近。

**关键点**：   

- 对缓存对象的 **读取** 和 **写入** 操作均视为对该对象的使用，需更新其访问时间戳或优先级。   

## 6.4 线程同步机制   

缓存的访问必须保证 **线程安全**，且需解决多线程环境下的竞态条件问题。

本部分的核心挑战在于：   

- **允许多线程并发读**：多个线程可同时从缓存中读取对象。  

* **限制单线程写**：

  同一时间仅允许一个线程修改缓存（如写入新对象或淘汰旧对象）。   

* **不可接受的方案**：   

  - 使用单一互斥锁（mutex）保护整个缓存会导致读操作串行化，违背并发读要求。   

  - **可行的同步策略**：   

    1. **缓存分区**：     - 将缓存划分为多个独立区域，每个区域由独立锁保护。此方法可降低锁粒度，提升并发性。   

    2. **读写锁（Readers-Writers Locks）**：     - 使用 Pthreads 提供的读写锁（如 `pthread_rwlock_t`），允许多线程同时读，写操作独占锁。   

    3. **自定义信号量方案**：     - 基于信号量（semaphore）实现读写同步逻辑，例如通过计数器管理读者和写者的访问权限。   
    4. **设计灵活性**：   - 由于无需严格实现 LRU 淘汰策略，可在支持多线程读时适当简化逻辑（例如使用近似 LRU 或二次机会算法），以平衡性能与实现复杂度。   

* **关键提示**：   - 淘汰策略的实现需与同步机制协同设计。例如，在更新对象访问时间戳时需加锁，但读取时间戳时可允许并发。   - 建议在代码中明确注释同步逻辑，确保临界区（critical section）的覆盖范围最小化，避免死锁或性能瓶颈。

# 7 评分标准   

本次实验总分为 70 分，具体分配如下：   

- **基础功能（BasicCorrectness）**：40 分（自动评分）   

- **并发处理（Concurrency）**：15 分（自动评分）   

- **缓存实现（Cache）**：15 分（自动评分）   

##  7.1 自动评分   

实验资料包中包含自动评分脚本 `driver.sh`，用于评估上述三项功能。

在 `proxylab-handout` 目录下运行：  

 ```bash   linux> ./driver.sh   ```   

**注意**：脚本需在 Linux 环境下执行。   

##  7.2 健壮性要求   

代理程序需具备容错能力，能处理错误甚至恶意输入。

具体要求包括：   

- **长期稳定运行**：代理作为常驻进程，不应因普通错误而崩溃退出。   

- **内存与资源管理**：禁止出现段错误、内存泄漏或文件描述符泄漏。   

# 8 测试与调试   

除自动评分脚本外，需自行设计测试用例和调试方案。

建议结合以下工具：   

## 8.1 Tiny Web 服务器   

实验资料包含简易 Web 服务器 `Tiny` 的源码，可用于本地测试。该服务器也是自动评分脚本的底层依赖。   

## 8.2 Telnet   通过 Telnet 手动连接代理并发送 HTTP 请求（参考教材 11.5.3 节）。

例如：   ```   telnet localhost <代理端口>   GET http://目标URL HTTP/1.0   ```   

## 8.3 Curl   

使用 Curl 发送代理请求（示例）：   

```bash   linux> curl -v --proxy http://localhost:代理端口 http://目标URL   ```   

此命令会显示详细请求与响应头，便于调试。   

## 8.4 Netcat (nc)   

- **客户端模式**：连接代理并发送请求（类似 Telnet）：    ```bash    nc 代理主机名 代理端口    ```   

- **服务器模式**：监听端口以捕获代理转发的请求：    

  ```bash    nc -l 12345    ```   

## 8.5 浏览器测试   

配置 Firefox 使用代理：   

1. 进入 `Preferences > Advanced > Network > Settings`。   

2. 选择 "Manual proxy configuration"，填入代理地址和端口。   

**注意事项**：   

- 测试缓存时需禁用浏览器自身缓存（在开发者工具中设置）。   

#  9 提交说明   

1. 在代码目录执行以下命令生成提交文件：     

   ```bash     linux> make handin     ```     

   生成的 `proxylab-handin.tar` 文件即为提交内容。   

   （此处需补充具体提交方式说明，例如通过课程平台上传。）   

   # 10 提示与资源   

   1. **网络 I/O**：     - 避免使用标准 I/O 函数处理套接字，推荐使用资料包中的 `csapp.c` 提供的 **健壮 I/O (RIO)** 函数。     - 修改 `csapp.c` 的错误处理逻辑，确保代理不会异常终止。   

   2. **代码结构**：     
      - 可将缓存功能模块化为 `cache.c` 和 `cache.h`，并更新 `Makefile`。   

   3. **信号处理**：     
      - 忽略 `SIGPIPE` 信号，优雅处理 `write` 返回的 `EPIPE` 错误。   

   4. **二进制数据**：     - HTTP 内容可能包含二进制数据（如图片），确保 I/O 函数兼容二进制读写。   5. **协议兼容性**：     - 所有请求均以 HTTP/1.0 格式转发，无论原始请求版本。   

   **参考资料**：   

   - 教材第 10-12 章：系统级 I/O、网络编程、HTTP 协议与并发编程。   
   - - [RFC 1945](https://tools.ietf.org/html/rfc1945)：HTTP/1.0 完整规范。   祝您实验顺利！